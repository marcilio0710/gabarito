<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<title>Corretor de Prova OMR</title>
<script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
<style>
  body { font-family: sans-serif; text-align: center; }
  video, canvas { width: 90%; max-width: 400px; margin: 10px auto; }
  #nota { font-size: 1.2em; margin: 10px; }
</style>
</head>
<body>
<h1>Corretor OMR no Navegador</h1>
<video id="videoInput" autoplay playsinline></video>
<canvas id="canvasOutput"></canvas>
<div id="nota">Aguardando inicialização...</div>

<script>
const ANSWER_KEY = {
  0: 1, 1: 4, 2: 0, 3: 3, 4: 1,
  5: 4, 6: 3, 7: 2, 8: 1, 9: 0
};
const FPS = 10;

let video = document.getElementById('videoInput');
let canvas = document.getElementById('canvasOutput');
let notaDiv = document.getElementById('nota');

let cap, src, gray, out;

function startCamera() {
  navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
    .then(stream => {
      video.srcObject = stream;
      video.play();
    })
    .catch(err => {
      notaDiv.innerText = `Erro ao acessar câmera: ${err}`;
    });
}

function onOpenCvReady() {
  console.log('OpenCV pronto!');
  notaDiv.innerText = 'Carregando câmera...';
  startCamera();

  video.addEventListener('canplay', () => {
    if (!cap) {
      video.width = video.videoWidth;
      video.height = video.videoHeight;

      cap = new cv.VideoCapture(video);
      src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
      gray = new cv.Mat();
      out = new cv.Mat.zeros(video.videoHeight, video.videoWidth, cv.CV_8UC3);

      notaDiv.innerText = 'Captura ativa. Processando...';
      processVideo();
    }
  });
}

function processVideo() {
  if (!cap) return;

  const begin = Date.now();

  cap.read(src);

  // Verificação rápida: se a captura está funcionando
  if (src.empty()) {
    console.log('Imagem vazia, aguardando...');
    setTimeout(processVideo, 100);
    return;
  }

  // Converte para cinza
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  // Aplica desfoque suave
  cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
  // Detecta bordas
  cv.Canny(gray, gray, 75, 200);

  // Para verificar se os contornos estão sendo detectados
  const cnts = new cv.MatVector();
  const hierarchy = new cv.Mat();
  cv.findContours(gray, cnts, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const bubbles = [];
  for (let i = 0; i < cnts.size(); i++) {
    const c = cnts.get(i);
    const r = cv.boundingRect(c);
    const ar = r.width / r.height;
    if (r.width > 10 && r.height > 10 && ar > 0.8 && ar < 1.2) {
      bubbles.push({ ctr: c, rect: r });
    }
  }

  // Debug: mostra quantidade de bolhas detectadas
  console.log('Bolhas detectadas:', bubbles.length);

  // Organiza bolhas por posição
  bubbles.sort((a, b) => a.rect.y - b.rect.y || a.rect.x - b.rect.x);

  // Agrupa por questões
  const rows = [];
  const choices = 5;
  for (let i = 0; i < bubbles.length; i += choices) {
    rows.push(bubbles.slice(i, i + choices));
  }

  let correctCount = 0;
  // Limpa a saída
  out.setTo(new cv.Scalar(0, 0, 0, 255));

  // Para cada questão
  rows.forEach((row, qi) => {
    let maxIdx = -1, maxVal = -1;
    for (let j = 0; j < row.length; j++) {
      const b = row[j];
      const mask = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
      cv.drawContours(mask, new cv.MatVector(b.ctr), -1, new cv.Scalar(255), -1);
      const m = new cv.Mat();
      cv.bitwise_and(gray, mask, m);
      const cnt = cv.countNonZero(m);
      if (cnt > maxVal) {
        maxVal = cnt;
        maxIdx = j;
      }
      m.delete(); mask.delete();
    }

    // Desenhar resposta na tela
    if (maxIdx >= 0) {
      const rect = row[maxIdx].rect;
      const centerX = rect.x + rect.width / 2;
      const centerY = rect.y + rect.height / 2;
      // Cor verde se correta, vermelho se errada
      const color = (maxIdx === ANSWER_KEY[qi]) ? [0, 255, 0, 255] : [0, 0, 255, 255];
      cv.circle(out, new cv.Point(centerX, centerY), rect.width / 2, color, 4);

      if (maxIdx === ANSWER_KEY[qi]) {
        correctCount++;
      }
    } else {
      console.log(`Questão ${qi+1}: nenhuma resposta detectada`);
    }
  });

  // Debug: mostrar quantidade de acertos no frame
  console.log('Acertos neste frame:', correctCount);

  // Para garantir que o canvas funciona, desenhe um retângulo de teste
  // cv.rectangle(out, new cv.Point(10, 10), new cv.Point(100, 100), [255, 0, 0, 255], 3);

  // Exibe na tela
  cv.imshow(canvas, out);

  // Atualiza nota
  const total = Object.keys(ANSWER_KEY).length;
  notaDiv.innerText = `Acertos: ${correctCount}/${total} — Nota: ${((correctCount/total)*100).toFixed(1)}%`;

  // Libera memória
  cnts.delete(); hierarchy.delete();

  // Próximo frame
  const delay = Math.max(0, 1000 / FPS - (Date.now() - begin));
  setTimeout(processVideo, delay);
}

cv['onRuntimeInitialized'] = onOpenCvReady;
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Corretor OMR - Reconhecimento Completo</title>
  <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <style>
    /* (Mantenha os estilos anteriores) */
  </style>
</head>
<body>
  <!-- (Mantenha a estrutura HTML anterior) -->

  <script>
    // Configurações atualizadas
    const CONFIG = {
      answerKey: {0:0, 1:0, 2:1, 3:1, 4:2, 5:2, 6:3, 7:3, 8:2, 9:2},
      optionsPerQuestion: 5,
      minBubbleArea: 150,
      maxBubbleArea: 3000,
      minFillPercentage: 40,
      maxLineHeightVariation: 15,
      rowGroupingThreshold: 0.5
    };

    // (Mantenha as declarações de elementos e estado)

    const app = {
      // (Mantenha as outras funções)

      sortBubbles: function(bubbles) {
        // Agrupa por linhas primeiro
        const rows = [];
        let currentRow = [bubbles[0]];
        
        for (let i = 1; i < bubbles.length; i++) {
          const prevCenterY = currentRow[currentRow.length-1].center.y;
          const currCenterY = bubbles[i].center.y;
          
          // Se estiver na mesma linha (com margem de erro)
          if (Math.abs(currCenterY - prevCenterY) < CONFIG.maxLineHeightVariation) {
            currentRow.push(bubbles[i]);
          } else {
            // Ordena a linha atual por coordenada X
            currentRow.sort((a, b) => a.center.x - b.center.x);
            rows.push(currentRow);
            currentRow = [bubbles[i]];
          }
        }
        
        // Adiciona a última linha
        if (currentRow.length > 0) {
          currentRow.sort((a, b) => a.center.x - b.center.x);
          rows.push(currentRow);
        }
        
        // Retorna achatado
        return rows.flat();
      },

      processAnswers: function(bubbles) {
        const results = [];
        let correctCount = 0;
        
        // Agrupa em questões (cada questão tem 5 alternativas)
        const questions = [];
        for (let i = 0; i < bubbles.length; i += CONFIG.optionsPerQuestion) {
          questions.push(bubbles.slice(i, i + CONFIG.optionsPerQuestion));
        }
        
        // Processa cada questão
        questions.forEach((questionBubbles, qIndex) => {
          if (qIndex >= Object.keys(CONFIG.answerKey).length) return;
          
          const markedIndex = this.detectMarkedBubble(questionBubbles);
          const isCorrect = markedIndex === CONFIG.answerKey[qIndex];
          
          if (isCorrect) correctCount++;
          
          results.push({
            question: qIndex + 1,
            marked: markedIndex + 1,
            correct: CONFIG.answerKey[qIndex] + 1,
            isCorrect
          });
        });
        
        return { answers: results, correctCount };
      },

      detectMarkedBubble: function(bubbles) {
        let markedIndex = -1;
        let maxFill = 0;
        
        bubbles.forEach((bubble, index) => {
          const mask = new cv.Mat.zeros(binary.rows, binary.cols, cv.CV_8UC1);
          cv.drawContours(mask, new cv.MatVector(bubble.contour), -1, 255, -1);
          
          const masked = new cv.Mat();
          cv.bitwise_and(binary, mask, masked);
          const fillPixels = cv.countNonZero(masked);
          const totalPixels = bubble.rect.width * bubble.rect.height;
          const fillPercentage = (fillPixels / totalPixels) * 100;
          
          if (fillPercentage > CONFIG.minFillPercentage && fillPercentage > maxFill) {
            maxFill = fillPercentage;
            markedIndex = index;
          }
          
          mask.delete();
          masked.delete();
        });
        
        return markedIndex;
      },

      // (Mantenha as outras funções)
    };

    document.addEventListener('DOMContentLoaded', () => app.init());
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<title>Corretor de Prova OMR</title>
<script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
<style>
  body { font-family: sans-serif; text-align: center; }
  video, canvas { width: 90%; max-width: 400px; margin: 10px auto; }
  #nota { font-size: 1.2em; margin: 10px; }
</style>
</head>
<body>
<h1>Corretor OMR no Navegador</h1>
<video id="videoInput" autoplay playsinline></video>
<canvas id="canvasOutput"></canvas>
<div id="nota">Aguardando inicialização...</div>

<script>
const ANSWER_KEY = {
  0: 1, 1: 4, 2: 0, 3: 3, 4: 1,
  5: 4, 6: 3, 7: 2, 8: 1, 9: 0
};
const FPS = 10;

let video = document.getElementById('videoInput');
let canvas = document.getElementById('canvasOutput');
let notaDiv = document.getElementById('nota');

let cap, src, gray, out;

// Função para iniciar a câmera
function startCamera() {
  navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false })
    .then(stream => {
      video.srcObject = stream;
      video.play();
    })
    .catch(err => {
      notaDiv.innerText = `Erro ao acessar câmera: ${err}`;
    });
}

// Quando o OpenCV estiver carregado
function onOpenCvReady() {
  console.log('OpenCV pronto!');
  notaDiv.innerText = 'Carregando câmera...';
  startCamera();

  // Quando o vídeo estiver pronto para ser usado
  video.addEventListener('canplay', () => {
    if (!cap) {
      // Ajusta o tamanho do vídeo
      video.width = video.videoWidth;
      video.height = video.videoHeight;

      // Inicializa as variáveis do OpenCV
      cap = new cv.VideoCapture(video);
      src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
      gray = new cv.Mat();
      out = new cv.Mat.zeros(video.videoHeight, video.videoWidth, cv.CV_8UC3);

      notaDiv.innerText = 'Captura ativa. Processando...';

      // Começa o processamento contínuo
      processVideo();
    }
  });
}

// Função principal de processamento
function processVideo() {
  if (!cap) return;

  const begin = Date.now();

  // Leitura do frame
  cap.read(src);
  // Convertendo para escala de cinza
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  // Aplicando desfoque
  cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
  // Detecção de bordas
  cv.Canny(gray, gray, 75, 200);

  // Encontrar contornos
  const cnts = new cv.MatVector();
  const hierarchy = new cv.Mat();
  cv.findContours(gray, cnts, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const bubbles = [];
  for (let i = 0; i < cnts.size(); i++) {
    const c = cnts.get(i);
    const r = cv.boundingRect(c);
    const ar = r.width / r.height;
    // Filtrar por tamanho e formato
    if (r.width > 10 && r.height > 10 && ar > 0.8 && ar < 1.2) {
      bubbles.push({ ctr: c, rect: r });
    }
  }
  console.log('Bolhas detectadas:', bubbles.length);

  // Ordenar bolhas por posição
  bubbles.sort((a, b) => a.rect.y - b.rect.y || a.rect.x - b.rect.x);

  // Agrupar por questões (cada questão tem 5 opções)
  const rows = [];
  const choices = 5;
  for (let i = 0; i < bubbles.length; i += choices) {
    rows.push(bubbles.slice(i, i + choices));
  }
  console.log('Linhas de questões:', rows.length);

  let correctCount = 0;
  out.setTo(new cv.Scalar(0, 0, 0, 255)); // Limpa a saída

  // Para cada questão
  rows.forEach((row, qi) => {
    // Para cada opção na questão
    let maxIdx = -1, maxVal = -1;
    for (let j = 0; j < row.length; j++) {
      const b = row[j];
      // Cria máscara para a bolha
      const mask = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
      cv.drawContours(mask, new cv.MatVector(b.ctr), -1, new cv.Scalar(255), -1);
      // Aplica máscara na imagem cinza
      const m = new cv.Mat();
      cv.bitwise_and(gray, mask, m);
      const cnt = cv.countNonZero(m);
      if (cnt > maxVal) {
        maxVal = cnt;
        maxIdx = j;
      }
      m.delete(); mask.delete();
    }

    // Verifica resposta correta
    const answeredIdx = maxIdx;
    const correctIdx = ANSWER_KEY[qi];

    if (answeredIdx >= 0) {
      // Desenha círculo na resposta
      const centerX = row[answeredIdx].rect.x + row[answeredIdx].rect.width / 2;
      const centerY = row[answeredIdx].rect.y + row[answeredIdx].rect.height / 2;
      const color = (answeredIdx === correctIdx) ? [0, 255, 0, 255] : [0, 0, 255, 255];
      cv.circle(out, new cv.Point(centerX, centerY), row[answeredIdx].rect.width / 2, color, 4);

      // Incrementa acertos se estiver correto
      if (answeredIdx === correctIdx) {
        correctCount++;
      }
    } else {
      console.log(`Questão ${qi+1}: nenhuma resposta detectada`);
    }
  });

  // Log de acertos por quadro
  console.log('Acertos neste frame:', correctCount);

  // Exibe a imagem no canvas
  cv.imshow(canvas, out);

  // Atualiza a nota na tela
  const total = Object.keys(ANSWER_KEY).length;
  notaDiv.innerText = `Acertos: ${correctCount}/${total} — Nota: ${((correctCount/total)*100).toFixed(1)}%`;

  // Libera memória
  cnts.delete(); hierarchy.delete();

  // Agendamento próximo frame
  const delay = Math.max(0, 1000 / FPS - (Date.now() - begin));
  setTimeout(processVideo, delay);
}

// Quando o OpenCV estiver pronto
cv['onRuntimeInitialized'] = onOpenCvReady;
</script>
</body>
</html>

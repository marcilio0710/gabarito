<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Corretor OMR Completo</title>
  <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    #videoContainer { position: relative; margin-bottom: 15px; }
    video, canvas { width: 100%; border: 2px solid #ddd; border-radius: 8px; display: block; }
    #captureBtn { 
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: #4285f4;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      z-index: 10;
    }
    #captureBtn:disabled { background: #cccccc; cursor: not-allowed; }
    #status { padding: 10px; margin: 10px 0; border-radius: 5px; }
    .ready { background: #e8f5e9; color: #2e7d32; }
    .error { background: #ffebee; color: #c62828; }
    #results { margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 8px; }
  </style>
</head>
<body>
  <h1>Corretor de Gabarito Inteligente</h1>
  <div id="status" class="ready">Iniciando sistema...</div>
  
  <div id="videoContainer">
    <video id="videoInput" autoplay playsinline muted></video>
    <button id="captureBtn" disabled>Capturar Gabarito</button>
    <canvas id="canvasOutput"></canvas>
  </div>
  
  <div id="results">Aguardando processamento...</div>

  <script>
    // Configurações
    const ANSWER_KEY = {0:1, 1:4, 2:0, 3:3, 4:1, 5:4, 6:3, 7:2, 8:1, 9:0};
    const OPTIONS_PER_QUESTION = 5;
    const MIN_BUBBLE_AREA = 150;
    const MAX_BUBBLE_AREA = 3000;

    // Elementos
    const video = document.getElementById('videoInput');
    const canvas = document.getElementById('canvasOutput');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const resultsDiv = document.getElementById('results');
    const captureBtn = document.getElementById('captureBtn');
    const videoContainer = document.getElementById('videoContainer');

    // Estado
    let stream = null;
    let processing = false;
    let openCvReady = false;
    let cameraReady = false;

    // Inicialização da câmera
    async function initCamera() {
      updateStatus("Acessando câmera...");
      
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          updateStatus("Câmera pronta. Aguardando OpenCV...");
          cameraReady = true;
          checkReadyState();
        };
        
        video.onerror = () => {
          updateStatus("Erro na câmera", true);
        };
        
      } catch (err) {
        updateStatus(`Erro ao acessar câmera: ${err.message}`, true);
      }
    }

    // Verifica se ambos estão prontos
    function checkReadyState() {
      if (openCvReady && cameraReady) {
        updateStatus("Sistema pronto para capturar gabaritos");
        captureBtn.disabled = false;
      }
    }

    // Processamento do gabarito
    function processAnswerSheet() {
      if (processing) return;
      processing = true;
      captureBtn.disabled = true;
      updateStatus("Processando gabarito...");
      
      try {
        // Ajusta canvas para o tamanho do vídeo
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Converte para OpenCV
        const src = cv.imread(canvas);
        const gray = new cv.Mat();
        const binary = new cv.Mat();
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        
        // Pré-processamento
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
        cv.adaptiveThreshold(gray, binary, 255, 
                           cv.ADAPTIVE_THRESH_GAUSSIAN_C, 
                           cv.THRESH_BINARY_INV, 11, 2);
        
        // Encontra contornos
        cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        // Filtra bolhas
        const bubbles = [];
        for (let i = 0; i < contours.size(); i++) {
          const contour = contours.get(i);
          const rect = cv.boundingRect(contour);
          const area = rect.width * rect.height;
          
          if (area > MIN_BUBBLE_AREA && area < MAX_BUBBLE_AREA) {
            bubbles.push({
              contour,
              rect,
              center: { x: rect.x + rect.width/2, y: rect.y + rect.height/2 }
            });
          }
        }
        
        // Ordena bolhas
        bubbles.sort((a, b) => {
          const yDiff = a.center.y - b.center.y;
          if (Math.abs(yDiff) > a.rect.height * 0.6) return yDiff;
          return a.center.x - b.center.x;
        });
        
        // Processa respostas
        const results = [];
        let correctCount = 0;
        
        for (let i = 0; i < bubbles.length; i += OPTIONS_PER_QUESTION) {
          const questionBubbles = bubbles.slice(i, i + OPTIONS_PER_QUESTION);
          const qIndex = i / OPTIONS_PER_QUESTION;
          
          if (qIndex >= Object.keys(ANSWER_KEY).length) break;
          
          let markedIndex = -1;
          let maxPixels = 0;
          
          questionBubbles.forEach((bubble, bIndex) => {
            const mask = new cv.Mat.zeros(binary.rows, binary.cols, cv.CV_8UC1);
            cv.drawContours(mask, new cv.MatVector(bubble.contour), -1, 255, -1);
            
            const masked = new cv.Mat();
            cv.bitwise_and(binary, mask, masked);
            const pixels = cv.countNonZero(masked);
            
            if (pixels > maxPixels) {
              maxPixels = pixels;
              markedIndex = bIndex;
            }
            
            mask.delete();
            masked.delete();
          });
          
          const isCorrect = markedIndex === ANSWER_KEY[qIndex];
          if (isCorrect) correctCount++;
          
          results.push({
            question: qIndex + 1,
            marked: markedIndex + 1,
            correct: ANSWER_KEY[qIndex] + 1,
            isCorrect
          });
        }
        
        // Exibe resultados
        displayResults(results, correctCount);
        
        // Desenha na imagem
        bubbles.forEach((bubble, i) => {
          const qIndex = Math.floor(i / OPTIONS_PER_QUESTION);
          if (qIndex >= results.length) return;
          
          const result = results[qIndex];
          if ((i % OPTIONS_PER_QUESTION) === result.marked - 1) {
            const center = new cv.Point(bubble.center.x, bubble.center.y);
            const radius = bubble.rect.width / 2;
            const color = result.isCorrect ? new cv.Scalar(0, 255, 0) : new cv.Scalar(0, 0, 255);
            cv.circle(src, center, radius, color, 3);
          }
        });
        
        cv.imshow(canvas, src);
        
        // Libera memória
        src.delete();
        gray.delete();
        binary.delete();
        contours.delete();
        hierarchy.delete();
        
      } catch (err) {
        updateStatus(`Erro: ${err.message}`, true);
        console.error(err);
      } finally {
        processing = false;
        captureBtn.disabled = false;
      }
    }

    // Exibe resultados
    function displayResults(results, correctCount) {
      const total = Object.keys(ANSWER_KEY).length;
      const score = Math.round((correctCount / total) * 100);
      
      let html = `<h3>Resultado: ${correctCount}/${total} (${score}%)</h3><table>`;
      html += `<tr><th>Questão</th><th>Marcada</th><th>Correta</th><th>Status</th></tr>`;
      
      results.forEach(r => {
        html += `<tr>
          <td>${r.question}</td>
          <td>${r.marked || '-'}</td>
          <td>${r.correct}</td>
          <td class="${r.isCorrect ? 'ready' : 'error'}">
            ${r.isCorrect ? '✓' : '✗'}
          </td>
        </tr>`;
      });
      
      html += `</table>`;
      resultsDiv.innerHTML = html;
      updateStatus("Processamento concluído!");
    }

    // Atualiza status
    function updateStatus(message, isError = false) {
      statusDiv.textContent = message;
      statusDiv.className = isError ? 'error' : 'ready';
    }

    // Quando OpenCV estiver pronto
    function onOpenCVReady() {
      openCvReady = true;
      updateStatus("OpenCV carregado");
      checkReadyState();
    }

    // Inicialização
    document.addEventListener('DOMContentLoaded', () => {
      // Configura OpenCV
      if (window.cv) {
        cv.onRuntimeInitialized = onOpenCVReady;
      } else {
        window.cv = { onRuntimeInitialized: onOpenCVReady };
      }
      
      // Inicia câmera
      initCamera();
      
      // Configura botão
      captureBtn.addEventListener('click', processAnswerSheet);
    });

    // Limpeza
    window.addEventListener('beforeunload', () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Corretor OMR - Detec√ß√£o Ultra Precis√£o</title>
  <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .header {
      text-align: center;
      margin-bottom: 20px;
    }
    .camera-box {
      background-color: white;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      position: relative;
    }
    video, canvas {
      width: 100%;
      border-radius: 8px;
      display: block;
      margin: 0 auto;
    }
    #captureBtn {
      display: block;
      width: 200px;
      margin: 15px auto;
      padding: 12px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #captureBtn:hover {
      background-color: #3367d6;
    }
    #captureBtn:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .status-box {
      padding: 12px;
      border-radius: 5px;
      margin-bottom: 15px;
      font-weight: 500;
    }
    .status-ready {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    .status-error {
      background-color: #ffebee;
      color: #c62828;
    }
    .results-box {
      background-color: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    .results-table th, .results-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }
    .results-table th {
      background-color: #f9f9f9;
    }
    .correct {
      color: #388e3c;
    }
    .incorrect {
      color: #d32f2f;
    }
    .summary {
      font-size: 18px;
      font-weight: bold;
      margin: 15px 0;
      text-align: center;
    }
    .debug-info {
      margin-top: 20px;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
      font-family: monospace;
    }
    .advanced-controls {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .slider-container {
      margin: 10px 0;
    }
    .slider-container label {
      display: inline-block;
      width: 200px;
      font-weight: bold;
    }
    .slider-container input[type="range"] {
      width: 300px;
      vertical-align: middle;
    }
    .slider-container span {
      display: inline-block;
      width: 60px;
      text-align: right;
      margin-left: 10px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Corretor Autom√°tico de Gabaritos</h1>
    <p>Gabarito Configurado: 1-A, 2-A, 3-B, 4-B, 5-C, 6-C, 7-D, 8-D, 9-C, 10-C</p>
  </div>

  <div class="status-box" id="status">Inicializando sistema...</div>

  <div class="camera-box">
    <video id="videoInput" autoplay playsinline muted></video>
    <canvas id="canvasOutput"></canvas>
    <button id="captureBtn" disabled>Capturar Gabarito</button>
  </div>

  <div class="advanced-controls">
    <h3>üîß Controles Avan√ßados</h3>
    <div class="slider-container">
      <label for="minFillSlider">Sensibilidade de Preenchimento:</label>
      <input type="range" id="minFillSlider" min="10" max="90" value="40">
      <span id="minFillValue">40%</span>
    </div>
    <div class="slider-container">
      <label for="colorThresholdSlider">Sensibilidade √† Cor:</label>
      <input type="range" id="colorThresholdSlider" min="0" max="100" value="30">
      <span id="colorThresholdValue">30</span>
    </div>
    <div class="slider-container">
      <label for="contrastSlider">Contraste:</label>
      <input type="range" id="contrastSlider" min="50" max="200" value="100">
      <span id="contrastValue">100%</span>
    </div>
    <button id="applySettings">Aplicar Configura√ß√µes</button>
  </div>

  <div class="results-box">
    <h2>üìä Resultados</h2>
    <div id="results">Aguardando processamento do gabarito...</div>
    <div class="debug-info" id="debugInfo"></div>
  </div>

  <script>
    // CONFIGURA√á√ÉO INICIAL
    const DEFAULT_CONFIG = {
      answerKey: {
        0: 0, 1: 0, 2: 1, 3: 1, 4: 2,
        5: 2, 6: 3, 7: 3, 8: 2, 9: 2
      },
      optionsPerQuestion: 5,
      minBubbleArea: 100,
      maxBubbleArea: 3500,
      minFillPercentage: 40,
      maxLineHeightVariation: 25,
      colorThreshold: 30,
      contrastLevel: 100,
      blueDetection: true,
      blackDetection: true,
      morphIterations: 2
    };

    // Elementos da interface
    const elements = {
      video: document.getElementById('videoInput'),
      canvas: document.getElementById('canvasOutput'),
      ctx: document.getElementById('canvasOutput').getContext('2d'),
      status: document.getElementById('status'),
      results: document.getElementById('results'),
      captureBtn: document.getElementById('captureBtn'),
      debugInfo: document.getElementById('debugInfo'),
      minFillSlider: document.getElementById('minFillSlider'),
      minFillValue: document.getElementById('minFillValue'),
      colorThresholdSlider: document.getElementById('colorThresholdSlider'),
      colorThresholdValue: document.getElementById('colorThresholdValue'),
      contrastSlider: document.getElementById('contrastSlider'),
      contrastValue: document.getElementById('contrastValue'),
      applySettings: document.getElementById('applySettings')
    };

    // Estado do sistema
    const state = {
      stream: null,
      processing: false,
      openCvReady: false,
      cameraReady: false,
      videoDimensions: { width: 0, height: 0 },
      binary: null,
      debugData: [],
      config: {...DEFAULT_CONFIG},
      lastProcessedImage: null
    };

    // Fun√ß√µes principais
    const app = {
      init: function() {
        this.setupOpenCV();
        this.initCamera();
        this.setupEventListeners();
      },

      setupOpenCV: function() {
        if (window.cv) {
          cv.onRuntimeInitialized = this.onOpenCVReady.bind(this);
        } else {
          window.cv = { onRuntimeInitialized: this.onOpenCVReady.bind(this) };
          elements.status.textContent = "Carregando OpenCV...";
        }
      },

      initCamera: async function() {
        elements.status.textContent = "Iniciando c√¢mera...";
        
        try {
          state.stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          });
          
          elements.video.srcObject = state.stream;
          
          elements.video.onloadedmetadata = () => {
            state.videoDimensions.width = elements.video.videoWidth;
            state.videoDimensions.height = elements.video.videoHeight;
            state.cameraReady = true;
            this.updateSystemStatus();
          };
          
        } catch (error) {
          this.showError(`Erro na c√¢mera: ${error.message}`);
        }
      },

      onOpenCVReady: function() {
        state.openCvReady = true;
        this.updateSystemStatus();
      },

      updateSystemStatus: function() {
        if (state.cameraReady && state.openCvReady) {
          elements.status.textContent = "‚úÖ Sistema pronto para uso";
          elements.status.className = "status-box status-ready";
          elements.captureBtn.disabled = false;
        } else if (!state.cameraReady && !state.openCvReady) {
          elements.status.textContent = "Inicializando c√¢mera e OpenCV...";
          elements.status.className = "status-box";
        } else if (!state.cameraReady) {
          elements.status.textContent = "Aguardando inicializa√ß√£o da c√¢mera...";
          elements.status.className = "status-box";
        } else {
          elements.status.textContent = "Aguardando carregamento do OpenCV...";
          elements.status.className = "status-box";
        }
      },

      processAnswerSheet: async function() {
        if (state.processing) return;
        
        state.processing = true;
        elements.captureBtn.disabled = true;
        elements.status.textContent = "üîÑ Processando gabarito...";
        elements.status.className = "status-box";
        state.debugData = [];
        
        try {
          elements.canvas.width = state.videoDimensions.width;
          elements.canvas.height = state.videoDimensions.height;
          elements.ctx.drawImage(elements.video, 0, 0, elements.canvas.width, elements.canvas.height);
          
          const results = await this.processImageWithOpenCV(elements.canvas);
          this.displayResults(results);
          this.displayDebugInfo();
          
        } catch (error) {
          this.showError(`Erro no processamento: ${error.message}`);
        } finally {
          state.processing = false;
          elements.captureBtn.disabled = false;
        }
      },

      processImageWithOpenCV: function(canvas) {
        return new Promise((resolve, reject) => {
          try {
            const src = cv.imread(canvas);
            state.lastProcessedImage = src.clone();
            
            // Aplica contraste
            const contrasted = new cv.Mat();
            src.convertTo(contrasted, -1, state.config.contrastLevel/100, 0);
            
            // Pr√©-processamento para detec√ß√£o de cor
            const hsv = new cv.Mat();
            cv.cvtColor(contrasted, hsv, cv.COLOR_RGBA2RGB);
            cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
            
            // Detecta azul (matizes entre 90-130)
            const blueMask = new cv.Mat();
            if (state.config.blueDetection) {
              const lowBlue = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [90, 70, 50, 0]);
              const highBlue = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [130, 255, 255, 0]);
              cv.inRange(hsv, lowBlue, highBlue, blueMask);
              lowBlue.delete();
              highBlue.delete();
            }
            
            // Detecta preto (matiz irrelevante, baixo valor)
            const blackMask = new cv.Mat();
            if (state.config.blackDetection) {
              const lowBlack = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 0, 0, 0]);
              const highBlack = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), 
                [180, 255, state.config.colorThreshold, 0]);
              cv.inRange(hsv, lowBlack, highBlack, blackMask);
              lowBlack.delete();
              highBlack.delete();
            }
            
            // Combina m√°scaras
            const colorMask = new cv.Mat();
            if (state.config.blueDetection && state.config.blackDetection) {
              cv.bitwise_or(blueMask, blackMask, colorMask);
            } else if (state.config.blueDetection) {
              colorMask = blueMask.clone();
            } else {
              colorMask = blackMask.clone();
            }
            
            // Processamento tradicional para formas
            const gray = new cv.Mat();
            cv.cvtColor(contrasted, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
            
            // Detec√ß√£o de bordas usando Canny
            const edges = new cv.Mat();
            cv.Canny(gray, edges, 50, 150); // Ajuste os valores de threshold se necess√°rio
            
            // Combina detec√ß√£o de cor com detec√ß√£o de bordas
            const combined = new cv.Mat();
            cv.bitwise_and(edges, colorMask, combined);
            
            // Opera√ß√µes morfol√≥gicas
            const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
            cv.morphologyEx(combined, combined, cv.MORPH_CLOSE, kernel, 
                          new cv.Point(-1, -1), state.config.morphIterations);
            
            // Encontra contornos
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            cv.findContours(combined, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            
            const bubbles = this.filterBubbles(contours);
            const sortedBubbles = this.sortBubbles(bubbles);
            const results = this.processAnswers(sortedBubbles);
            
            this.drawResults(contrasted, sortedBubbles, results);
            cv.imshow(canvas, contrasted);
            
            // Liberar mem√≥ria
            src.delete();
            contrasted.delete();
            hsv.delete();
            blueMask.delete();
            blackMask.delete();
            colorMask.delete();
            gray.delete();
            edges.delete();
            combined.delete();
            contours.delete();
            hierarchy.delete();
            kernel.delete();
            
            resolve(results);
            
          } catch (error) {
            reject(error);
          }
        });
      },

      filterBubbles: function(contours) {
        const bubbles = [];
        
        for (let i = 0; i < contours.size(); i++) {
          const contour = contours.get(i);
          const rect = cv.boundingRect(contour);
          const area = rect.width * rect.height;
          const aspectRatio = rect.width / rect.height;
          
          if (area > state.config.minBubbleArea && 
              area < state.config.maxBubbleArea &&
              aspectRatio > 0.7 && aspectRatio < 1.4) {
            bubbles.push({
              contour,
              rect,
              center: { x: rect.x + rect.width/2, y: rect.y + rect.height/2 },
              area
            });
          }
        }
        
        return bubbles;
      },

      sortBubbles: function(bubbles) {
        if (bubbles.length === 0) return bubbles;
        
        // Primeiro ordena por posi√ß√£o Y (linhas)
        bubbles.sort((a, b) => a.center.y - b.center.y);
        
        // Agrupa por linhas
        const rows = [];
        let currentRow = [bubbles[0]];
        
        for (let i = 1; i < bubbles.length; i++) {
          const prevCenterY = currentRow[currentRow.length-1].center.y;
          const currCenterY = bubbles[i].center.y;
          
          if (Math.abs(currCenterY - prevCenterY) < state.config.maxLineHeightVariation) {
            currentRow.push(bubbles[i]);
          } else {
            // Ordena cada linha por posi√ß√£o X (colunas)
            currentRow.sort((a, b) => a.center.x - b.center.x);
            rows.push(currentRow);
            currentRow = [bubbles[i]];
          }
        }
        
        if (currentRow.length > 0) {
          currentRow.sort((a, b) => a.center.x - b.center.x);
          rows.push(currentRow);
        }
        
        return rows.flat();
      },

      processAnswers: function(bubbles) {
        const results = [];
        let correctCount = 0;
        
        // Agrupa bolhas por quest√£o
        const questions = [];
        const questionsCount = Math.ceil(bubbles.length / state.config.optionsPerQuestion);
        
        for (let q = 0; q < questionsCount; q++) {
          const startIdx = q * state.config.optionsPerQuestion;
          const endIdx = startIdx + state.config.optionsPerQuestion;
          questions.push(bubbles.slice(startIdx, endIdx));
        }
        
        // Processa cada quest√£o
        questions.forEach((questionBubbles, qIndex) => {
          if (qIndex >= Object.keys(state.config.answerKey).length) return;
          
          const markedIndex = this.detectMarkedBubble(questionBubbles, qIndex);
          const isCorrect = markedIndex === state.config.answerKey[qIndex];
          
          if (isCorrect) correctCount++;
          
          results.push({
            question: qIndex + 1,
            marked: markedIndex !== -1 ? this.indexToLetter(markedIndex) : '-',
            correct: this.indexToLetter(state.config.answerKey[qIndex]),
            isCorrect,
            debug: state.debugData[qIndex] || {}
          });
        });
        
        return { answers: results, correctCount };
      },

      indexToLetter: function(index) {
        return String.fromCharCode(65 + index); // 0=A, 1=B, etc.
      },

      detectMarkedBubble: function(bubbles, qIndex) {
        let markedIndex = -1;
        let maxFill = 0;
        const debugInfo = {};
        
        bubbles.forEach((bubble, index) => {
          const contourVector = new cv.MatVector();
          contourVector.push_back(bubble.contour);
          
          const mask = new cv.Mat.zeros(state.lastProcessedImage.rows, 
                                      state.lastProcessedImage.cols, cv.CV_8UC1);
          cv.drawContours(mask, contourVector, -1, new cv.Scalar(255, 255, 255, 255), -1);
          
          // Analisa a regi√£o dentro do contorno
          const roi = new cv.Mat();
          state.lastProcessedImage.copyTo(roi, mask);
          
          // Converte para HSV para an√°lise de cor
          const hsvRoi = new cv.Mat();
          cv.cvtColor(roi, hsvRoi, cv.COLOR_RGBA2RGB);
          cv.cvtColor(hsvRoi, hsvRoi, cv.COLOR_RGB2HSV);
          
          // Calcula a m√©dia do valor (V no HSV) que indica qu√£o escura est√° a regi√£o
          const meanValue = cv.mean(hsvRoi)[2];
          const fillPercentage = 100 - (meanValue / 255 * 100);
          
          debugInfo[`Q${qIndex+1}-${this.indexToLetter(index)}`] = `${fillPercentage.toFixed(1)}%`;
          
          if (fillPercentage > state.config.minFillPercentage && fillPercentage > maxFill) {
            maxFill = fillPercentage;
            markedIndex = index;
          }
          
          // Liberar mem√≥ria
          mask.delete();
          roi.delete();
          hsvRoi.delete();
          contourVector.delete();
        });
        
        state.debugData[qIndex] = debugInfo;
        return markedIndex;
      },

      drawResults: function(src, bubbles, results) {
        bubbles.forEach((bubble, i) => {
          const qIndex = Math.floor(i / state.config.optionsPerQuestion);
          if (qIndex >= results.answers.length) return;
          
          const answer = results.answers[qIndex];
          const optionIndex = i % state.config.optionsPerQuestion;
          
          if (optionIndex === answer.marked.charCodeAt(0) - 65 || answer.marked === '-') {
            const color = answer.isCorrect 
              ? new cv.Scalar(0, 255, 0, 255)  // Verde para correto
              : new cv.Scalar(0, 0, 255, 255);  // Vermelho para incorreto
            
            const thickness = 2;
            const contourVector = new cv.MatVector();
            contourVector.push_back(bubble.contour);
            cv.drawContours(src, contourVector, -1, color, thickness);
            contourVector.delete();
          }
        });
      },

      displayResults: function(results) {
        const totalQuestions = Object.keys(state.config.answerKey).length;
        const score = Math.round((results.correctCount / totalQuestions) * 100);
        
        let html = `
          <div class="summary">
            Pontua√ß√£o: ${results.correctCount}/${totalQuestions} (${score}%)
          </div>
          <table class="results-table">
            <thead>
              <tr>
                <th>Quest√£o</th>
                <th>Sua Resposta</th>
                <th>Resposta Correta</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
        `;
        
        results.answers.forEach(answer => {
          html += `
            <tr>
              <td>${answer.question}</td>
              <td>${answer.marked}</td>
              <td>${answer.correct}</td>
              <td class="${answer.isCorrect ? 'correct' : 'incorrect'}">
                ${answer.isCorrect ? '‚úì' : '‚úó'}
              </td>
            </tr>
          `;
        });
        
        html += `</tbody></table>`;
        elements.results.innerHTML = html;
        elements.status.textContent = "‚úÖ Processamento conclu√≠do com sucesso!";
        elements.status.className = "status-box status-ready";
      },

      displayDebugInfo: function() {
        let debugHtml = "<h3>üîç Informa√ß√µes de Debug:</h3><ul>";
        
        state.debugData.forEach((questionDebug, qIndex) => {
          debugHtml += `<li><strong>Quest√£o ${qIndex + 1}:</strong> `;
          debugHtml += Object.entries(questionDebug)
            .map(([key, value]) => `${key}=${value}`)
            .join(", ");
          debugHtml += "</li>";
        });
        
        debugHtml += "</ul>";
        elements.debugInfo.innerHTML = debugHtml;
      },

      showError: function(message) {
        elements.status.textContent = message;
        elements.status.className = "status-box status-error";
        console.error(message);
      },

      setupEventListeners: function() {
        elements.captureBtn.addEventListener('click', () => this.processAnswerSheet());
        
        // Controles avan√ßados
        elements.minFillSlider.addEventListener('input', (e) => {
          state.config.minFillPercentage = parseInt(e.target.value);
          elements.minFillValue.textContent = `${state.config.minFillPercentage}%`;
        });
        
        elements.colorThresholdSlider.addEventListener('input', (e) => {
          state.config.colorThreshold = parseInt(e.target.value);
          elements.colorThresholdValue.textContent = state.config.colorThreshold;
        });
        
        elements.contrastSlider.addEventListener('input', (e) => {
          state.config.contrastLevel = parseInt(e.target.value);
          elements.contrastValue.textContent = `${state.config.contrastLevel}%`;
        });
        
        elements.applySettings.addEventListener('click', () => {
          if (state.lastProcessedImage) {
            this.processAnswerSheet();
          }
        });
        
        window.addEventListener('beforeunload', () => {
          if (state.stream) {
            state.stream.getTracks().forEach(track => track.stop());
          }
          if (state.binary) {
            state.binary.delete();
          }
        });
      }
    };

    document.addEventListener('DOMContentLoaded', () => app.init());
  </script>
</body>
</html>

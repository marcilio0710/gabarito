<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Corretor OMR Avançado</title>
  <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    .container { display: flex; flex-wrap: wrap; gap: 20px; }
    .camera-container, .result-container { flex: 1; min-width: 300px; }
    video, canvas { width: 100%; border: 2px solid #ddd; border-radius: 8px; }
    #status { padding: 10px; background: #f0f0f0; border-radius: 5px; margin-bottom: 10px; }
    #results { margin-top: 20px; padding: 15px; background: #f8f8f8; border-radius: 8px; }
    .error { color: #d32f2f; }
    .success { color: #388e3c; }
    button {
      background: #4285f4;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }
    button:hover { background: #3367d6; }
  </style>
</head>
<body>
  <h1>Corretor de Gabarito Inteligente</h1>
  <div id="status">Inicializando sistema...</div>
  
  <div class="container">
    <div class="camera-container">
      <h2>Câmera</h2>
      <video id="videoInput" autoplay playsinline muted></video>
      <button id="captureBtn" disabled>Capturar Gabarito</button>
    </div>
    
    <div class="result-container">
      <h2>Resultado</h2>
      <canvas id="canvasOutput"></canvas>
      <div id="results">Aguardando processamento...</div>
    </div>
  </div>

  <script>
    // Configurações do gabarito
    const ANSWER_KEY = {0:1, 1:4, 2:0, 3:3, 4:1, 5:4, 6:3, 7:2, 8:1, 9:0};
    const OPTIONS_PER_QUESTION = 5;
    const MIN_BUBBLE_AREA = 100;
    const MAX_BUBBLE_AREA = 5000;
    
    // Elementos da página
    const video = document.getElementById('videoInput');
    const canvas = document.getElementById('canvasOutput');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const resultsDiv = document.getElementById('results');
    const captureBtn = document.getElementById('captureBtn');
    
    // Variáveis de estado
    let processing = false;
    let stream = null;
    let lastResults = null;

    // Inicializa a câmera
    async function initCamera() {
      updateStatus("Solicitando acesso à câmera...");
      
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        });
        
        video.srcObject = stream;
        updateStatus("Câmera inicializada com sucesso");
        captureBtn.disabled = false;
        
        // Verifica se o OpenCV já está carregado
        if (window.cv) {
          onOpenCVReady();
        } else {
          updateStatus("Aguardando carregamento do OpenCV...");
          window.cv = { onRuntimeInitialized: onOpenCVReady };
        }
      } catch (err) {
        updateStatus(`Erro ao acessar câmera: ${err.message}`, true);
      }
    }

    // Processa o gabarito
    function processAnswerSheet() {
      if (processing) return;
      processing = true;
      
      try {
        // Ajusta o canvas para o tamanho do vídeo
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Converte a imagem para processamento com OpenCV
        const src = cv.imread(canvas);
        const gray = new cv.Mat();
        const binary = new cv.Mat();
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        
        // Pré-processamento da imagem
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
        cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, 
                            cv.THRESH_BINARY_INV, 11, 2);
        
        // Encontra contornos
        cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
        // Filtra bolhas do gabarito
        const bubbles = [];
        for (let i = 0; i < contours.size(); i++) {
          const contour = contours.get(i);
          const rect = cv.boundingRect(contour);
          const area = rect.width * rect.height;
          const aspectRatio = rect.width / rect.height;
          
          // Critérios para identificar bolhas
          if (area > MIN_BUBBLE_AREA && area < MAX_BUBBLE_AREA && 
              aspectRatio > 0.7 && aspectRatio < 1.4) {
            bubbles.push({
              contour,
              rect,
              center: { x: rect.x + rect.width/2, y: rect.y + rect.height/2 }
            });
          }
        }
        
        // Ordena bolhas: primeiro por linha (y), depois por coluna (x)
        bubbles.sort((a, b) => {
          const yDiff = a.center.y - b.center.y;
          if (Math.abs(yDiff) > a.rect.height * 0.5) return yDiff;
          return a.center.x - b.center.x;
        });
        
        // Agrupa por questões (cada questão tem OPTIONS_PER_QUESTION alternativas)
        const questions = [];
        for (let i = 0; i < bubbles.length; i += OPTIONS_PER_QUESTION) {
          questions.push(bubbles.slice(i, i + OPTIONS_PER_QUESTION));
        }
        
        // Processa cada questão
        const results = [];
        let correctAnswers = 0;
        
        questions.forEach((question, qIndex) => {
          if (qIndex >= Object.keys(ANSWER_KEY).length) return;
          
          // Encontra a alternativa marcada (com maior área preta)
          let markedIndex = -1;
          let maxBlackPixels = 0;
          
          question.forEach((bubble, bIndex) => {
            const mask = new cv.Mat.zeros(binary.rows, binary.cols, cv.CV_8UC1);
            cv.drawContours(mask, new cv.MatVector(bubble.contour), -1, 255, -1);
            
            const masked = new cv.Mat();
            cv.bitwise_and(binary, mask, masked);
            const blackPixels = cv.countNonZero(masked);
            
            if (blackPixels > maxBlackPixels) {
              maxBlackPixels = blackPixels;
              markedIndex = bIndex;
            }
            
            mask.delete();
            masked.delete();
          });
          
          // Verifica se está correta
          const isCorrect = markedIndex === ANSWER_KEY[qIndex];
          if (isCorrect) correctAnswers++;
          
          results.push({
            question: qIndex + 1,
            marked: markedIndex + 1,
            correct: ANSWER_KEY[qIndex] + 1,
            isCorrect
          });
        });
        
        // Exibe resultados
        displayResults(results, correctAnswers);
        lastResults = results;
        
        // Desenha os resultados na imagem
        questions.forEach((question, qIndex) => {
          if (qIndex >= results.length) return;
          
          const result = results[qIndex];
          const bubble = question[result.marked - 1];
          
          if (bubble) {
            const center = new cv.Point(bubble.center.x, bubble.center.y);
            const radius = bubble.rect.width / 2;
            const color = result.isCorrect ? new cv.Scalar(0, 255, 0) : new cv.Scalar(0, 0, 255);
            cv.circle(src, center, radius, color, 3);
          }
        });
        
        cv.imshow(canvas, src);
        
        // Libera memória
        src.delete();
        gray.delete();
        binary.delete();
        contours.delete();
        hierarchy.delete();
        
      } catch (err) {
        updateStatus(`Erro no processamento: ${err.message}`, true);
        console.error(err);
      } finally {
        processing = false;
      }
    }

    // Exibe os resultados na página
    function displayResults(results, correctCount) {
      const totalQuestions = Object.keys(ANSWER_KEY).length;
      const score = Math.round((correctCount / totalQuestions) * 100);
      
      let html = `
        <h3>Resultado: ${correctCount}/${totalQuestions} (${score}%)</h3>
        <table>
          <tr>
            <th>Questão</th>
            <th>Resposta Marcada</th>
            <th>Resposta Correta</th>
            <th>Status</th>
          </tr>
      `;
      
      results.forEach(result => {
        html += `
          <tr>
            <td>${result.question}</td>
            <td>${result.marked || '-'}</td>
            <td>${result.correct}</td>
            <td class="${result.isCorrect ? 'success' : 'error'}">
              ${result.isCorrect ? '✓' : '✗'}
            </td>
          </tr>
        `;
      });
      
      html += `</table>`;
      resultsDiv.innerHTML = html;
      updateStatus("Processamento concluído com sucesso!");
    }

    // Atualiza o status na página
    function updateStatus(message, isError = false) {
      statusDiv.textContent = message;
      statusDiv.className = isError ? 'error' : '';
      console.log(message);
    }

    // Quando o OpenCV estiver pronto
    function onOpenCVReady() {
      updateStatus("OpenCV carregado e pronto para uso");
      captureBtn.addEventListener('click', processAnswerSheet);
    }

    // Inicia a aplicação
    document.addEventListener('DOMContentLoaded', () => {
      initCamera();
      
      // Configura callback do OpenCV se ainda não estiver pronto
      if (!window.cv) {
        window.cv = { onRuntimeInitialized: onOpenCVReady };
      }
    });

    // Limpa recursos quando a página é fechada
    window.addEventListener('beforeunload', () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>

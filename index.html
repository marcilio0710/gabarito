<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Corretor de Prova OMR</title>
  <script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; }
    video, canvas { width: 90%; max-width: 400px; }
    #nota { font-size: 1.2em; margin: 10px; }
  </style>
</head>
<body>
  <h1>Corretor OMR no Navegador</h1>
  <video id="videoInput" autoplay playsinline></video>
  <canvas id="canvasOutput"></canvas>
  <div id="nota">Aguardando inicialização...</div>

  <script>
    const ANSWER_KEY = {0:1,1:4,2:0,3:3,4:1};
    const FPS = 10;
    let video = document.getElementById('videoInput');
    let canvas = document.getElementById('canvasOutput');
    let notaDiv = document.getElementById('nota');
    let cap, src, gray, out;

    function startCamera() {
      navigator.mediaDevices.getUserMedia({ video: true, audio: false })
        .then(stream => {
          video.srcObject = stream;
          video.play();
        })
        .catch(err => {
          notaDiv.innerText = `Erro ao acessar câmera: ${err}`;
        });
    }

    function onOpenCvReady() {
      notaDiv.innerText = 'Carregando câmera...';
      startCamera();
      video.addEventListener('canplay', () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        cap = new cv.VideoCapture(video);
        src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
        gray = new cv.Mat();
        out = new cv.Mat.zeros(video.videoHeight, video.videoWidth, cv.CV_8UC3);
        notaDiv.innerText = 'Captura ativa. Processando...';
        processVideo();
      });
    }

    function processVideo() {
      let begin = Date.now();
      cap.read(src);
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
      cv.Canny(gray, gray, 75, 200);

      let cnts = new cv.MatVector(), hierarchy = new cv.Mat();
      cv.findContours(gray, cnts, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let bubbles = [];
      for (let i = 0; i < cnts.size(); i++) {
        let c = cnts.get(i);
        let r = cv.boundingRect(c);
        let ar = r.width / r.height;
        if (r.width > 20 && r.height > 20 && ar > 0.9 && ar < 1.1) {
          bubbles.push({ctr: c, rect: r});
        }
      }

      bubbles.sort((a,b) => a.rect.y - b.rect.y || a.rect.x - b.rect.x);
      let rows = [];
      for (let i = 0; i < bubbles.length; i += 5)
        rows.push(bubbles.slice(i, i + 5));

      let correctCount = 0;
      rows.forEach((row, qi) => {
        let maxIdx = -1, maxVal = 0;
        row.forEach((b, j) => {
          let mask = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
          cv.drawContours(mask, new cv.MatVector(b.ctr), -1, new cv.Scalar(255), -1);
          let m = new cv.Mat();
         

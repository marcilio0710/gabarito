<!DOCTYPE html>
<html lang="pt-BR">
<head><meta charset="UTF-8" /><title>Corretor OMR</title>
  <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; }
    video, canvas { width:90%; max-width:400px; margin:10px auto; }
    #nota { font-size:1.2em; margin:10px; }
  </style>
</head>
<body>
  <h1>Corretor OMR</h1>
  <video id="videoInput" autoplay playsinline muted></video>
  <canvas id="canvasOutput"></canvas>
  <div id="nota">Aguardando...</div>
  <script>
    const ANSWER_KEY = {0:1,1:4,2:0,3:3,4:1,5:4,6:3,7:2,8:1,9:0};
    const FPS = 10;
    const video = document.getElementById('videoInput');
    const outC = document.getElementById('canvasOutput');
    const nota = document.getElementById('nota');
    const hidden = document.createElement('canvas');
    const hctx = hidden.getContext('2d');
    let cap, src, gray, out;

    function startCamera() {
      navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}})
        .then(s=>{video.srcObject=s; video.play();})
        .catch(e=>nota.innerText = `Erro câmera: ${e}`);
    }

    function onOpenCvReady() {
      nota.innerText = 'Iniciando câmera...';
      startCamera();
      video.addEventListener('canplay', () => {
        if (!cap) {
          hidden.width = video.videoWidth;
          hidden.height = video.videoHeight;
          outC.width = video.videoWidth;
          outC.height = video.videoHeight;
          cap = new cv.VideoCapture(hidden);
          src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
          gray = new cv.Mat();
          out = new cv.Mat.zeros(video.videoHeight, video.videoWidth, cv.CV_8UC3);
          nota.innerText = 'Captura ativa. Processando...';
          setTimeout(processVideo, 0);
        }
      });
    }

    function processVideo() {
      hctx.drawImage(video, 0, 0, hidden.width, hidden.height);
      cap.read(src);
      if (src.empty()) {
        console.warn('Frame vazio');
        return setTimeout(processVideo, 1000/FPS);
      }

      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      cv.Canny(gray, gray, 75, 200);

      const cnts = new cv.MatVector(), hier = new cv.Mat();
      cv.findContours(gray, cnts, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      const bubbles = [];
      for (let i = 0; i < cnts.size(); i++) {
        const c = cnts.get(i);
        const r = cv.boundingRect(c);
        const ar = r.width/r.height;
        if (r.width > 10 && r.height > 10 && ar > 0.8 && ar < 1.3) bubbles.push({ctr:c,rect:r});
      }
      console.log('Bolhas detectadas:', bubbles.length);

      bubbles.sort((a,b)=>a.rect.y - b.rect.y || a.rect.x - b.rect.x);
      const rows = [];
      for (let i=0; i<bubbles.length; i+=5) rows.push(bubbles.slice(i, i+5));
      console.log('Linhas (questões):', rows.length);

      out.setTo(new cv.Scalar(0,0,0,255));
      let correctCount = 0;

      rows.forEach((row, qi) => {
        let maxIdx = -1, maxVal = -1;
        row.forEach((b,j)=>{
          const mask = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
          cv.drawContours(mask, new cv.MatVector(b.ctr), -1, new cv.Scalar(255), -1);
          const m = new cv.Mat();
          cv.bitwise_and(gray, mask, m);
          const cnt = cv.countNonZero(m);
          if (cnt > maxVal) { maxVal = cnt; maxIdx = j; }
          m.delete(); mask.delete();
        });
        console.log(`Questão ${qi+1}: detectada=${maxIdx}, correta=${ANSWER_KEY[qi]}`);

        if (maxIdx >= 0) {
          const r = row[maxIdx].rect;
          const center = new cv.Point(r.x+r.width/2, r.y+r.height/2);
          const color = (maxIdx===ANSWER_KEY[qi]) ? [0,255,0,255] : [0,0,255,255];
          cv.circle(out, center, r.width/2, color, 4);
          if (maxIdx === ANSWER_KEY[qi]) correctCount++;
        }
      });
      console.log('Acertos no frame:', correctCount);

      cv.imshow(outC, out);
      nota.innerText = `Acertos: ${correctCount}/${Object.keys(ANSWER_KEY).length} — Nota: ${((correctCount/Object.keys(ANSWER_KEY).length)*100).toFixed(1)}%`;

      cnts.delete(); hier.delete();
      setTimeout(processVideo, 1000/FPS);
    }

    cv['onRuntimeInitialized'] = onOpenCvReady;
  </script>
</body>
</html>

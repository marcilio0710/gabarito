<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Corretor OMR - Versão Ultra Precisão</title>
  <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <style>
    /* (Mantenha todos os estilos anteriores) */
    .advanced-controls {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .slider-container {
      margin: 10px 0;
    }
    .slider-container label {
      display: inline-block;
      width: 200px;
      font-weight: bold;
    }
    .slider-container input[type="range"] {
      width: 300px;
      vertical-align: middle;
    }
    .slider-container span {
      display: inline-block;
      width: 60px;
      text-align: right;
      margin-left: 10px;
    }
  </style>
</head>
<body>
  <!-- (Mantenha a estrutura HTML anterior) -->

  <div class="advanced-controls">
    <h3>Controles Avançados</h3>
    <div class="slider-container">
      <label for="minFillSlider">Sensibilidade de Preenchimento:</label>
      <input type="range" id="minFillSlider" min="10" max="90" value="40">
      <span id="minFillValue">40%</span>
    </div>
    <div class="slider-container">
      <label for="colorThresholdSlider">Sensibilidade à Cor:</label>
      <input type="range" id="colorThresholdSlider" min="0" max="100" value="30">
      <span id="colorThresholdValue">30</span>
    </div>
    <div class="slider-container">
      <label for="contrastSlider">Contraste:</label>
      <input type="range" id="contrastSlider" min="0" max="200" value="100">
      <span id="contrastValue">100%</span>
    </div>
    <button id="applySettings">Aplicar Configurações</button>
  </div>

  <script>
    // CONFIGURAÇÃO INICIAL DO GABARITO
    const DEFAULT_CONFIG = {
      answerKey: {
        0: 0, 1: 0, 2: 1, 3: 1, 4: 2,
        5: 2, 6: 3, 7: 3, 8: 2, 9: 2
      },
      optionsPerQuestion: 5,
      minBubbleArea: 100,
      maxBubbleArea: 3500,
      minFillPercentage: 40,
      maxLineHeightVariation: 25,
      colorThreshold: 30,
      contrastLevel: 100,
      blueDetection: true,
      blackDetection: true,
      morphIterations: 2
    };

    // Elementos da interface
    const elements = {
      // (Mantenha elementos anteriores)
      minFillSlider: document.getElementById('minFillSlider'),
      minFillValue: document.getElementById('minFillValue'),
      colorThresholdSlider: document.getElementById('colorThresholdSlider'),
      colorThresholdValue: document.getElementById('colorThresholdValue'),
      contrastSlider: document.getElementById('contrastSlider'),
      contrastValue: document.getElementById('contrastValue'),
      applySettings: document.getElementById('applySettings')
    };

    // Estado do sistema
    const state = {
      // (Mantenha estado anterior)
      config: {...DEFAULT_CONFIG},
      lastProcessedImage: null
    };

    // Funções principais
    const app = {
      // (Mantenha funções init, setupOpenCV, initCamera, etc.)

      processImageWithOpenCV: function(canvas) {
        return new Promise((resolve, reject) => {
          try {
            const src = cv.imread(canvas);
            state.lastProcessedImage = src.clone();
            
            // Aplica contraste
            const contrasted = new cv.Mat();
            src.convertTo(contrasted, -1, state.config.contrastLevel/100, 0);
            
            // Pré-processamento para detecção de cor
            const hsv = new cv.Mat();
            cv.cvtColor(contrasted, hsv, cv.COLOR_RGBA2RGB);
            cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
            
            // Detecta azul (matizes entre 90-130)
            const blueMask = new cv.Mat();
            if (state.config.blueDetection) {
              const lowBlue = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [90, 70, 50, 0]);
              const highBlue = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [130, 255, 255, 0]);
              cv.inRange(hsv, lowBlue, highBlue, blueMask);
              lowBlue.delete();
              highBlue.delete();
            }
            
            // Detecta preto (matiz irrelevante, baixo valor)
            const blackMask = new cv.Mat();
            if (state.config.blackDetection) {
              const lowBlack = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 0, 0, 0]);
              const highBlack = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), 
                [180, 255, state.config.colorThreshold, 0]);
              cv.inRange(hsv, lowBlack, highBlack, blackMask);
              lowBlack.delete();
              highBlack.delete();
            }
            
            // Combina máscaras
            const colorMask = new cv.Mat();
            if (state.config.blueDetection && state.config.blackDetection) {
              cv.bitwise_or(blueMask, blackMask, colorMask);
            } else if (state.config.blueDetection) {
              colorMask = blueMask.clone();
            } else {
              colorMask = blackMask.clone();
            }
            
            // Processamento tradicional para formas
            const gray = new cv.Mat();
            cv.cvtColor(contrasted, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
            
            const binary = new cv.Mat();
            cv.adaptiveThreshold(gray, binary, 255, 
                               cv.ADAPTIVE_THRESH_GAUSSIAN_C, 
                               cv.THRESH_BINARY_INV, 
                               31, 7);
            
            // Combina detecção de cor com detecção de forma
            const combined = new cv.Mat();
            cv.bitwise_and(binary, colorMask, combined);
            
            // Operações morfológicas
            const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
            cv.morphologyEx(combined, combined, cv.MORPH_CLOSE, kernel, 
                          new cv.Point(-1, -1), state.config.morphIterations);
            
            // Encontra contornos
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            cv.findContours(combined, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            
            const bubbles = this.filterBubbles(contours);
            const sortedBubbles = this.sortBubbles(bubbles);
            const results = this.processAnswers(sortedBubbles);
            
            this.drawResults(contrasted, sortedBubbles, results);
            cv.imshow(canvas, contrasted);
            
            // Liberar memória
            src.delete();
            contrasted.delete();
            hsv.delete();
            blueMask.delete();
            blackMask.delete();
            colorMask.delete();
            gray.delete();
            binary.delete();
            combined.delete();
            contours.delete();
            hierarchy.delete();
            kernel.delete();
            
            resolve(results);
            
          } catch (error) {
            reject(error);
          }
        });
      },

      detectMarkedBubble: function(bubbles, qIndex) {
        let markedIndex = -1;
        let maxFill = 0;
        const debugInfo = {};
        
        bubbles.forEach((bubble, index) => {
          const contourVector = new cv.MatVector();
          contourVector.push_back(bubble.contour);
          
          const mask = new cv.Mat.zeros(state.lastProcessedImage.rows, 
                                      state.lastProcessedImage.cols, cv.CV_8UC1);
          cv.drawContours(mask, contourVector, -1, new cv.Scalar(255, 255, 255, 255), -1);
          
          // Analisa a região dentro do contorno
          const roi = new cv.Mat();
          state.lastProcessedImage.copyTo(roi, mask);
          
          // Converte para HSV para análise de cor
          const hsvRoi = new cv.Mat();
          cv.cvtColor(roi, hsvRoi, cv.COLOR_RGBA2RGB);
          cv.cvtColor(hsvRoi, hsvRoi, cv.COLOR_RGB2HSV);
          
          // Calcula a média do valor (V no HSV) que indica quão escura está a região
          const meanValue = cv.mean(hsvRoi)[2];
          const fillPercentage = 100 - (meanValue / 255 * 100);
          
          debugInfo[`Q${qIndex+1}-${this.indexToLetter(index)}`] = `${fillPercentage.toFixed(1)}%`;
          
          if (fillPercentage > state.config.minFillPercentage && fillPercentage > maxFill) {
            maxFill = fillPercentage;
            markedIndex = index;
          }
          
          // Liberar memória
          mask.delete();
          roi.delete();
          hsvRoi.delete();
          contourVector.delete();
        });
        
        state.debugData[qIndex] = debugInfo;
        return markedIndex;
      },

      // (Mantenha as outras funções)

      setupEventListeners: function() {
        // (Mantenha listeners anteriores)
        
        // Controles avançados
        elements.minFillSlider.addEventListener('input', (e) => {
          state.config.minFillPercentage = parseInt(e.target.value);
          elements.minFillValue.textContent = `${state.config.minFillPercentage}%`;
        });
        
        elements.colorThresholdSlider.addEventListener('input', (e) => {
          state.config.colorThreshold = parseInt(e.target.value);
          elements.colorThresholdValue.textContent = state.config.colorThreshold;
        });
        
        elements.contrastSlider.addEventListener('input', (e) => {
          state.config.contrastLevel = parseInt(e.target.value);
          elements.contrastValue.textContent = `${state.config.contrastLevel}%`;
        });
        
        elements.applySettings.addEventListener('click', () => {
          if (state.lastProcessedImage) {
            this.processAnswerSheet();
          }
        });
      }
    };

    document.addEventListener('DOMContentLoaded', () => app.init());
  </script>
</body>
</html>
